{"version":3,"sources":["webpack:///webpack/bootstrap 5009a11f159c5161f5f0","webpack:///./src/core/token.ts","webpack:///./src/core/interpreter.ts","webpack:///./src/core/scanner.ts","webpack:///./src/core/ast/stmt.ts","webpack:///./src/playground/lox-language/syntax.ts","webpack:///./node_modules/locate-character/dist/locate-character.es.js","webpack:///./src/core/parser.ts","webpack:///./src/core/environment.ts","webpack:///./src/playground/index.ts","webpack:///./src/playground/gist.ts","webpack:///./src/playground/examples.ts","webpack:///./src/playground/lox-language/main.ts","webpack:///./src/playground/lox-language/config.ts","webpack:///./src/playground/lox-language/autocomplete.ts","webpack:///./src/playground/lox-language/parser.ts","webpack:///./src/core/ast/expr.ts","webpack:///./src/core/runner.ts","webpack:///./src/core/callable.ts","webpack:///./src/core/class.ts","webpack:///./src/core/resolver.ts"],"names":[],"mappings":"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","file":"main.5009a11f159c5161f5f0.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 5009a11f159c5161f5f0","export default class Token {\n    type: TokenType;\n    lexeme: string;\n    literal: any;\n    start: number;\n\n    constructor(type: TokenType, lexeme: string, literal: any, start: number) {\n        this.type = type;\n        this.lexeme = lexeme;\n        this.literal = literal;\n        this.start = start;\n    }\n\n    get end() {\n        return this.start + this.lexeme.length;\n    }\n\n    toString() {\n        return `[${this.type}] ${this.lexeme} ${this.literal}`;\n    }\n\n    static equals(a: Token, b: Token) {\n        return (\n            a.type === b.type &&\n            a.lexeme === b.lexeme &&\n            a.literal === b.literal &&\n            a.start === b.start\n        );\n    }\n}\n\nexport enum TokenType {\n    // Single character tokens.\n    LEFT_PAREN,\n    RIGHT_PAREN,\n    LEFT_BRACE,\n    RIGHT_BRACE,\n    COMMA,\n    DOT,\n    MINUS,\n    PLUS,\n    SEMI,\n    SLASH,\n    STAR,\n\n    // One of two characters tokens.\n    BANG,\n    BANG_EQUAL,\n    EQUAL,\n    EQUAL_EQUAL,\n    GREATER,\n    GREATE_EQUAL,\n    LESS,\n    LESS_EQUAL,\n\n    // Literals\n    IDENTIFIER,\n    STRING,\n    NUMBER,\n\n    // Keywords\n    AND,\n    CLASS,\n    ELSE,\n    FALSE,\n    FUN,\n    FOR,\n    IF,\n    NIL,\n    OR,\n    PRINT,\n    RETURN,\n    SUPER,\n    THIS,\n    TRUE,\n    VAR,\n    WHILE,\n    BREAK,\n\n    // Others\n    EOF,\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/token.ts","import Runner from './runner';\nimport Token, { TokenType } from './token';\nimport * as Expr from './ast/expr';\nimport * as Stmt from './ast/stmt';\nimport Environment from './environment';\nimport { LoxCallable, LoxFunction } from './callable';\nimport { LoxClass, LoxInstance } from './class';\n\nexport class RuntimeException extends Error {\n    token: Token;\n    constructor(token: Token, message: string) {\n        super(message);\n        this.token = token;\n    }\n}\n\nclass BreakException extends Error {}\n\nexport class ReturnException extends Error {\n    value: any;\n    constructor(value: any) {\n        super();\n        this.value = value;\n    }\n}\n\nexport default class Interpreter\n    implements Expr.ExprVisitor<any>, Stmt.StmtVisitor<void> {\n    runner: Runner;\n\n    readonly locals: Map<Expr.Expr, number> = new Map();\n    readonly globals = new Environment();\n    private evironment = this.globals;\n\n    constructor(runner: Runner) {\n        this.runner = runner;\n\n        this.globals.define(\n            'clock',\n            new class Clock extends LoxCallable {\n                arity = 0;\n                call() {\n                    return Date.now();\n                }\n            }(),\n        );\n    }\n\n    interpret(statements: Stmt.Stmt[]) {\n        try {\n            for (let statement of statements) {\n                this.execute(statement);\n            }\n        } catch (error) {\n            if (error instanceof RuntimeException) {\n                this.runner.runtimeError(error);\n            }\n        }\n    }\n\n    private execute(statement: Stmt.Stmt) {\n        statement.accept(this);\n    }\n\n    visitFunctionStmt(stmt: Stmt.Function) {\n        const fn = new LoxFunction(\n            stmt.name.lexeme,\n            stmt.fn,\n            this.evironment,\n            false,\n        );\n        this.evironment.define(stmt.name.lexeme, fn);\n    }\n\n    visitFunctionExpr(expr: Expr.Function) {\n        return new LoxFunction(undefined, expr, this.evironment, false);\n    }\n\n    visitReturnStmt(stmt: Stmt.Return) {\n        let value;\n        if (stmt.value !== null) {\n            value = this.evaluate(stmt.value);\n        }\n\n        throw new ReturnException(value);\n    }\n\n    visitVarStmt(stmt: Stmt.Var) {\n        let value: any = null;\n        if (stmt.initializer != null) {\n            value = this.evaluate(stmt.initializer);\n        }\n\n        this.evironment.define(stmt.name.lexeme, value);\n    }\n\n    visitVariableExpr(expr: Expr.Variable) {\n        return this.lookupVariable(expr.name, expr);\n    }\n\n    visitClassStmt(stmt: Stmt.Class) {\n        this.evironment.define(stmt.name.lexeme, null);\n\n        const classMethods: { [name: string]: LoxFunction } = {};\n        for (let method of stmt.classMethods) {\n            classMethods[method.name.lexeme] = new LoxFunction(\n                method.name.lexeme,\n                method.fn,\n                this.evironment,\n                false,\n            );\n        }\n\n        const metaclass = new LoxClass(null, `${stmt.name.lexeme}meta`, classMethods);\n\n        const methods: { [name: string]: LoxFunction } = {};\n        for (let method of stmt.methods) {\n            methods[method.name.lexeme] = new LoxFunction(\n                method.name.lexeme,\n                method.fn,\n                this.evironment,\n                method.name.lexeme === 'init',\n            );\n        }\n\n        const klass = new LoxClass(metaclass, stmt.name.lexeme, methods);\n        this.evironment.assign(stmt.name, klass);\n    }\n\n    visitThisExpr(expr: Expr.This) {\n        return this.lookupVariable(expr.keyword, expr);\n    }\n\n    visitExpressionStmt(stmt: Stmt.Expression) {\n        this.evaluate(stmt.expr);\n    }\n\n    visitPrintStmt(stmt: Stmt.Print) {\n        const value = this.evaluate(stmt.expr);\n        this.runner.logger.log(value.toString());\n    }\n\n    visitBlockStmt(stmt: Stmt.Block) {\n        this.executeBlock(stmt, new Environment(this.evironment));\n    }\n\n    visitIfStmt(stmt: Stmt.If) {\n        if (this.isTruthy(this.evaluate(stmt.condition))) {\n            this.execute(stmt.thenBranch);\n        } else if (stmt.elseBranch) {\n            this.execute(stmt.elseBranch);\n        }\n    }\n\n    visitWhileStmt(stmt: Stmt.While) {\n        try {\n            while (this.isTruthy(this.evaluate(stmt.condition))) {\n                this.execute(stmt.body);\n            }\n        } catch (error) {\n            if (error instanceof BreakException) {\n                return;\n            }\n            throw error;\n        }\n    }\n\n    visitBreakStmt() {\n        throw new BreakException();\n    }\n\n    visitLogicalExpr(expr: Expr.Logical) {\n        const left = this.evaluate(expr.left);\n\n        if (expr.operator.type === TokenType.OR) {\n            if (this.isTruthy(left)) {\n                return left;\n            }\n        } else {\n            if (!this.isTruthy(left)) {\n                return left;\n            }\n        }\n\n        return this.evaluate(expr.right);\n    }\n\n    visitAssignExpr(expr: Expr.Assign): any {\n        const value = this.evaluate(expr.value);\n\n        const distance = this.locals.get(expr);\n        if (distance !== undefined) {\n            this.evironment.assignAt(distance, expr.name, value);\n        } else {\n            this.globals.assign(expr.name, value);\n        }\n\n        return value;\n    }\n\n    visitLiteralExpr(expr: Expr.Literal): any {\n        return expr.value;\n    }\n\n    visitGroupingExpr(expr: Expr.Grouping): any {\n        return this.evaluate(expr.expr);\n    }\n\n    visitUnaryExpr(expr: Expr.Unary): any {\n        const right = this.evaluate(expr.right);\n\n        switch (expr.operation.type) {\n            case TokenType.MINUS:\n                return -right;\n            case TokenType.BANG:\n                return !this.isTruthy(right);\n        }\n\n        return null;\n    }\n\n    visitCallExpr(expr: Expr.Call): any {\n        const fn = this.evaluate(expr.callee);\n\n        if (!(fn instanceof LoxCallable) && !(fn instanceof LoxClass)) {\n            throw new RuntimeException(\n                expr.paren,\n                'Can only call function and class methods.',\n            );\n        }\n\n        const args = expr.args.map(arg => this.evaluate(arg));\n\n        if (args.length !== fn.arity) {\n            throw new RuntimeException(\n                expr.paren,\n                `Expected ${fn.arity} arguments but got ${args.length}.`,\n            );\n        }\n\n        return fn.call(this, args);\n    }\n\n    visitGetExpr(expr: Expr.Get): any {\n        const object = this.evaluate(expr.object);\n\n        if (object instanceof LoxInstance) {\n            return object.get(expr.name);\n        }\n\n        throw new RuntimeException(\n            expr.name,\n            'Only instances have properties.',\n        );\n    }\n\n    visitSetExpr(expr: Expr.Set): any {\n        const object = this.evaluate(expr.object);\n\n        if (!(object instanceof LoxInstance)) {\n            throw new RuntimeException(\n                expr.name,\n                'Only instances have fields.',\n            );\n        }\n\n        const value = this.evaluate(expr.value);\n        object.set(expr.name, value);\n        return value;\n    }\n\n    visitBinaryExpr(expr: Expr.Binary): any {\n        const left = this.evaluate(expr.left);\n        const right = this.evaluate(expr.right);\n\n        switch (expr.operator.type) {\n            case TokenType.PLUS:\n                if (typeof left === 'string' || typeof right === 'string') {\n                    return String(left) + String(right);\n                } else if (\n                    typeof left === 'number' &&\n                    typeof right === 'number'\n                ) {\n                    return left + right;\n                }\n\n                throw new RuntimeException(\n                    expr.operator,\n                    'Operands must be 2 strings or numbers',\n                );\n\n            case TokenType.MINUS:\n                this.checkNumberOperands(expr.operator, left, right);\n                return left - right;\n\n            case TokenType.SLASH:\n                this.checkNumberOperands(expr.operator, left, right);\n                return left / right;\n\n            case TokenType.STAR:\n                this.checkNumberOperands(expr.operator, left, right);\n                return left * right;\n\n            case TokenType.GREATER:\n                this.checkNumberOperands(expr.operator, left, right);\n                return left > right;\n\n            case TokenType.GREATE_EQUAL:\n                this.checkNumberOperands(expr.operator, left, right);\n                return left >= right;\n\n            case TokenType.LESS:\n                this.checkNumberOperands(expr.operator, left, right);\n                return left < right;\n\n            case TokenType.LESS_EQUAL:\n                this.checkNumberOperands(expr.operator, left, right);\n                return left <= right;\n\n            case TokenType.BANG_EQUAL:\n                return !this.isEqual(left, right);\n\n            case TokenType.EQUAL_EQUAL:\n                return this.isEqual(left, right);\n        }\n\n        return null;\n    }\n\n    executeBlock(stmt: Stmt.Block, environment: Environment) {\n        const previousEnv = this.evironment;\n\n        try {\n            this.evironment = environment;\n\n            for (let statement of stmt.statements) {\n                this.execute(statement);\n            }\n        } finally {\n            this.evironment = previousEnv;\n        }\n    }\n\n    evaluate(expr: Expr.Expr): any {\n        return expr.accept(this);\n    }\n\n    resolve(expr: Expr.Expr, depth: number) {\n        this.locals.set(expr, depth);\n    }\n\n    private lookupVariable(name: Token, expr: Expr.Expr) {\n        const distance = this.locals.get(expr);\n\n        if (distance !== undefined) {\n            return this.evironment.getAt(distance, name.lexeme);\n        } else {\n            return this.globals.get(name);\n        }\n    }\n\n    private isTruthy(value: any): boolean {\n        return typeof value === 'boolean'\n            ? value\n            : value == null ? false : true;\n    }\n\n    private isEqual(a: any, b: any) {\n        return typeof a === typeof b ? a == b : false;\n    }\n\n    private checkNumberOperand(operator: Token, operand: any) {\n        if (typeof operand !== 'number') {\n            throw new RuntimeException(operator, 'Operand must be a number');\n        }\n    }\n\n    private checkNumberOperands(operator: Token, left: any, right: any) {\n        if (typeof left !== 'number' && typeof right !== 'number') {\n            throw new RuntimeException(operator, 'Operands must be 2 numbers');\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/interpreter.ts","import Runner from './runner';\nimport Token, { TokenType } from './token';\n\ninterface ScannerConfig {\n    error(location: number, msg: string): void\n}\n\nfunction isDigit(c: string) {\n    return c >= '0' && c <= '9';\n}\n\nfunction isAlpha(c: string) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');\n}\n\nfunction isAlphaNumeric(c: string) {\n    return isAlpha(c) || isDigit(c);\n}\n\nexport const KEYWORDS: Map<string, TokenType> = new Map([\n    ['and', TokenType.AND],\n    ['class', TokenType.CLASS],\n    ['else', TokenType.ELSE],\n    ['false', TokenType.FALSE],\n    ['for', TokenType.FOR],\n    ['if', TokenType.IF],\n    ['nil', TokenType.NIL],\n    ['or', TokenType.OR],\n    ['print', TokenType.PRINT],\n    ['return', TokenType.RETURN],\n    ['super', TokenType.SUPER],\n    ['this', TokenType.THIS],\n    ['true', TokenType.TRUE],\n    ['var', TokenType.VAR],\n    ['while', TokenType.WHILE],\n    ['break', TokenType.BREAK],\n    ['fun', TokenType.FUN],\n]);\n\n\nexport default class Scanner {\n    tokens: Token[] = [];\n    start = 0;\n    current = 0;\n\n    constructor(\n        public source: string, \n        public config: ScannerConfig\n    ) {}\n\n    scanTokens() {\n        while (!this.isAtEnd()) {\n            this.start = this.current;\n            this.scanToken();\n        }\n\n        this.tokens.push(new Token(TokenType.EOF, '', null, this.start));\n        return this.tokens;\n    }\n\n    private isAtEnd() {\n        return this.current >= this.source.length;\n    }\n\n    private advance() {\n        return this.source.charAt(this.current++);\n    }\n\n    private match(char: string) {\n        if (this.isAtEnd()) {\n            return false;\n        } else if (this.source.charAt(this.current) !== char) {\n            return false;\n        }\n\n        this.current++;\n        return true;\n    }\n\n    private peek() {\n        return this.isAtEnd() ? '\\0' : this.source.charAt(this.current);\n    }\n\n    private peekNext() {\n        return this.current + 1 >= this.source.length\n            ? '\\0'\n            : this.source.charAt(this.current + 1);\n    }\n\n    private addToken(type: TokenType, literal: any = null) {\n        const lexeme = this.source.slice(this.start, this.current);\n        this.tokens.push(new Token(type, lexeme, literal, this.start));\n    }\n\n    private scanToken() {\n        const c = this.advance();\n        switch (c) {\n            case '(':\n                this.addToken(TokenType.LEFT_PAREN);\n                break;\n\n            case ')':\n                this.addToken(TokenType.RIGHT_PAREN);\n                break;\n\n            case '{':\n                this.addToken(TokenType.LEFT_BRACE);\n                break;\n\n            case '}':\n                this.addToken(TokenType.RIGHT_BRACE);\n                break;\n\n            case ',':\n                this.addToken(TokenType.COMMA);\n                break;\n\n            case '.':\n                this.addToken(TokenType.DOT);\n                break;\n\n            case '.':\n                this.addToken(TokenType.DOT);\n                break;\n\n            case '-':\n                this.addToken(TokenType.MINUS);\n                break;\n\n            case '+':\n                this.addToken(TokenType.PLUS);\n                break;\n\n            case ';':\n                this.addToken(TokenType.SEMI);\n                break;\n\n            case '*':\n                this.addToken(TokenType.STAR);\n                break;\n\n            case '!':\n                this.addToken(\n                    this.match('=') ? TokenType.BANG_EQUAL : TokenType.BANG,\n                );\n                break;\n\n            case '=':\n                this.addToken(\n                    this.match('=') ? TokenType.EQUAL_EQUAL : TokenType.EQUAL,\n                );\n                break;\n\n            case '<':\n                this.addToken(\n                    this.match('=') ? TokenType.LESS_EQUAL : TokenType.LESS,\n                );\n                break;\n\n            case '>':\n                this.addToken(\n                    this.match('=')\n                        ? TokenType.GREATE_EQUAL\n                        : TokenType.GREATER,\n                );\n                break;\n\n            case '/':\n                if (this.match('/')) {\n                    // A comment goes untile the end of the line\n                    while (this.peek() !== '\\n' && !this.isAtEnd()) {\n                        this.advance();\n                    }\n                } else if (this.match('*')) {\n                    // A comment goes untile the end of the line\n                    while (\n                        this.peek() !== '*' &&\n                        this.peekNext() !== '/' &&\n                        !this.isAtEnd()\n                    ) {\n                        this.advance();\n                    }\n\n                    if (this.peek() !== '/') {\n                        // Discard closing */\n                        this.advance();\n                        this.advance();\n                    }\n                } else {\n                    this.addToken(TokenType.SLASH);\n                }\n\n                break;\n\n            case ' ':\n            case '\\r':\n            case '\\t':\n            case '\\n':\n                // Ignore whitespaces\n                break;\n\n            case '\"':\n                this.string();\n                break;\n\n            default:\n                if (isDigit(c)) {\n                    this.number();\n                } else if (isAlpha(c)) {\n                    this.identifier();\n                } else {\n                    this.config.error(this.current, `Unexpected character ${c}`);\n                }\n        }\n    }\n\n    private string() {\n        while (this.peek() !== '\"' && !this.isAtEnd()) {\n            this.advance();\n        }\n\n        if (this.isAtEnd()) {\n            this.config.error(this.current, 'Unterminated string.');\n            return;\n        }\n\n        // Consume closing '\"'\n        this.advance();\n\n        // Trimmed surrounding quotes\n        const value = this.source.slice(this.start + 1, this.current - 1);\n        this.addToken(TokenType.STRING, value);\n    }\n\n    private number() {\n        while (isDigit(this.peek())) {\n            this.advance();\n        }\n\n        // Floating numbers\n        let isFloat = false;\n        if (this.peek() === '.' && isDigit(this.peekNext())) {\n            // Consume '.'\n            this.advance();\n            isFloat = true;\n\n            while (isDigit(this.peek())) {\n                this.advance();\n            }\n        }\n\n        // Parse literal according to the type\n        const value = this.source.slice(this.start, this.current);\n        const literal = isFloat ? parseFloat(value) : parseFloat(value);\n\n        this.addToken(TokenType.NUMBER, literal);\n    }\n\n    private identifier() {\n        while (isAlphaNumeric(this.peek())) {\n            this.advance();\n        }\n\n        const text = this.source.slice(this.start, this.current);\n\n        let type = KEYWORDS.get(text);\n        if (type == null) {\n            type = TokenType.IDENTIFIER;\n        }\n\n        this.addToken(type);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/scanner.ts","/* /!\\ Genreated via \"npm run genreate-ast\" /!\\ */\n\nimport Token from '../token';\nimport { Expr, Function as FunctionExpr } from './expr';\n\nexport interface StmtVisitor<V> {\n    visitBlockStmt(stmt: Block): V;\n    visitExpressionStmt(stmt: Expression): V;\n    visitClassStmt(stmt: Class): V;\n    visitIfStmt(stmt: If): V;\n    visitWhileStmt(stmt: While): V;\n    visitBreakStmt(stmt: Break): V;\n    visitPrintStmt(stmt: Print): V;\n    visitVarStmt(stmt: Var): V;\n    visitFunctionStmt(stmt: Function): V;\n    visitReturnStmt(stmt: Return): V;\n}\n\nexport abstract class Stmt {\n    abstract accept<V>(visitior: StmtVisitor<V>): V;\n}\n\nexport class Block extends Stmt {\n    statements: Stmt[];\n    constructor(statements: Stmt[]) {\n        super();\n        this.statements = statements;\n    }\n    accept<V>(visitor: StmtVisitor<V>): V {\n        return visitor.visitBlockStmt(this);\n    }\n}\n\nexport class Expression extends Stmt {\n    expr: Expr;\n    constructor(expr: Expr) {\n        super();\n        this.expr = expr;\n    }\n    accept<V>(visitor: StmtVisitor<V>): V {\n        return visitor.visitExpressionStmt(this);\n    }\n}\n\nexport class Class extends Stmt {\n    name: Token;\n    methods: Function[];\n    classMethods: Function[];\n    constructor(name: Token, methods: Function[], classMethods: Function[]) {\n        super();\n        this.name = name;\n        this.methods = methods;\n        this.classMethods = classMethods;\n    }\n    accept<V>(visitor: StmtVisitor<V>): V {\n        return visitor.visitClassStmt(this);\n    }\n}\n\nexport class If extends Stmt {\n    condition: Expr;\n    thenBranch: Stmt;\n    elseBranch: Stmt | undefined;\n    constructor(\n        condition: Expr,\n        thenBranch: Stmt,\n        elseBranch: Stmt | undefined,\n    ) {\n        super();\n        this.condition = condition;\n        this.thenBranch = thenBranch;\n        this.elseBranch = elseBranch;\n    }\n    accept<V>(visitor: StmtVisitor<V>): V {\n        return visitor.visitIfStmt(this);\n    }\n}\n\nexport class While extends Stmt {\n    condition: Expr;\n    body: Stmt;\n    constructor(condition: Expr, body: Stmt) {\n        super();\n        this.condition = condition;\n        this.body = body;\n    }\n    accept<V>(visitor: StmtVisitor<V>): V {\n        return visitor.visitWhileStmt(this);\n    }\n}\n\nexport class Break extends Stmt {\n    constructor() {\n        super();\n    }\n    accept<V>(visitor: StmtVisitor<V>): V {\n        return visitor.visitBreakStmt(this);\n    }\n}\n\nexport class Print extends Stmt {\n    expr: Expr;\n    constructor(expr: Expr) {\n        super();\n        this.expr = expr;\n    }\n    accept<V>(visitor: StmtVisitor<V>): V {\n        return visitor.visitPrintStmt(this);\n    }\n}\n\nexport class Var extends Stmt {\n    name: Token;\n    initializer: Expr;\n    constructor(name: Token, initializer: Expr) {\n        super();\n        this.name = name;\n        this.initializer = initializer;\n    }\n    accept<V>(visitor: StmtVisitor<V>): V {\n        return visitor.visitVarStmt(this);\n    }\n}\n\nexport class Function extends Stmt {\n    name: Token;\n    fn: FunctionExpr;\n    constructor(name: Token, fn: FunctionExpr) {\n        super();\n        this.name = name;\n        this.fn = fn;\n    }\n    accept<V>(visitor: StmtVisitor<V>): V {\n        return visitor.visitFunctionStmt(this);\n    }\n}\n\nexport class Return extends Stmt {\n    keyword: Token;\n    value: Expr;\n    constructor(keyword: Token, value: Expr) {\n        super();\n        this.keyword = keyword;\n        this.value = value;\n    }\n    accept<V>(visitor: StmtVisitor<V>): V {\n        return visitor.visitReturnStmt(this);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/ast/stmt.ts","import { KEYWORDS as keywordsMap } from '../../core/scanner';\n\nexport const KEYWORDS = Array.from(keywordsMap.keys());\n\n/**\n * Syntax highlight defintion\n * https://microsoft.github.io/monaco-editor/monarch.html\n */\nexport const MONARCH_TOKEN_PROVIDER = {\n    ignoreCase: true,\n\n    keywords: KEYWORDS,\n    \n    operators: ['=', '>', '<', '!', '?', ':', '==', '<=', '>=', '!='],\n\n    tokenizer: {\n        root: [\n            [\n                /[a-zA-Z][a-zA-Z0-9]*/,\n                {\n                    cases: {\n                        '@keywords': 'keyword',\n                        '@default': 'identifier',\n                    },\n                },\n            ],\n\n            [/\\/\\*/, 'comment', '@comment'],\n            [/\\/\\/.*/, 'comment'],\n\n            [/\"/, 'string', '@string'],\n\n            [/\\d+\\.\\d+/, 'number.float'],\n            [/\\d+/, 'number'],\n        ],\n\n        comment: [[/[^\\/*]+/, 'comment'], ['\\\\*/', 'comment', '@pop']],\n\n        string: [[/[^\"]+/, 'string'], [/\"/, 'string', '@pop']],\n    },\n};\n\n\n// WEBPACK FOOTER //\n// ./src/playground/lox-language/syntax.ts","function getLocator(source, options) {\n    if (options === void 0) { options = {}; }\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n        var end = start + line.length + 1;\n        var range = { start: start, end: end, line: i };\n        start = end;\n        return range;\n    });\n    var i = 0;\n    function rangeContains(range, index) {\n        return range.start <= index && index < range.end;\n    }\n    function getLocation(range, index) {\n        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };\n    }\n    function locate(search, startIndex) {\n        if (typeof search === 'string') {\n            search = source.indexOf(search, startIndex || 0);\n        }\n        var range = lineRanges[i];\n        var d = search >= range.end ? 1 : -1;\n        while (range) {\n            if (rangeContains(range, search))\n                return getLocation(range, search);\n            i += d;\n            range = lineRanges[i];\n        }\n    }\n    ;\n    return locate;\n}\nfunction locate(source, search, options) {\n    if (typeof options === 'number') {\n        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n    return getLocator(source, options)(search, options && options.startIndex);\n}\n\nexport { getLocator, locate };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/locate-character/dist/locate-character.es.js\n// module id = 5\n// module chunks = 0","import Runner from './runner';\nimport Token, { TokenType } from './token';\n\nimport * as Stmt from './ast/stmt';\nimport * as Expr from './ast/expr';\nimport { Class } from './ast/stmt';\n\nclass ParserError extends Error {}\n\ninterface ParserConfig {\n    error(token: Token, msg: string): void;\n}\n\nexport default class Parser {\n    current = 0;\n    loopDepth = 0;\n\n    constructor(\n        public tokens: Token[], \n        public config: ParserConfig\n    ) {}\n\n    parse(): Stmt.Stmt[] {\n        const statements = [];\n\n        while (!this.isAtEnd()) {\n            const statement = this.declaration();\n            if (statement) {\n                statements.push(statement);\n            }\n        }\n\n        return statements;\n    }\n\n    // declaration → funDecl | varDecl | classDecl | statement ;\n    private declaration(): Stmt.Stmt | undefined {\n        try {\n            if (this.match(TokenType.FUN)) {\n                return this.function('function');\n            } else if (this.match(TokenType.VAR)) {\n                return this.varDeclaration();\n            } else if (this.match(TokenType.CLASS)) {\n                return this.classDeclaration();\n            } else {\n                return this.statement();\n            }\n        } catch (error) {\n            if (error instanceof ParserError) {\n                this.synchronize();\n            }\n        }\n    }\n\n    // funDecl -> \"fun\" function\n    // function -> IDENTIFIER \"(\" parameters? \")\" block\n    private function(kind: string): Stmt.Function {\n        const name = this.consume(\n            TokenType.IDENTIFIER,\n            `Expected ${kind} name.`,\n        );\n\n        const body = this.functionBody(kind);\n\n        return new Stmt.Function(name, body);\n    }\n\n    private functionBody(kind: string) {\n        this.consume(TokenType.LEFT_PAREN, `Expected \"(\" after ${kind} name.`);\n\n        const parameters = [];\n        if (!this.check(TokenType.RIGHT_PAREN)) {\n            do {\n                if (parameters.length >= 8) {\n                    this.error(\n                        this.peek(),\n                        'Cannot have more than 8 parameters.',\n                    );\n                }\n\n                parameters.push(\n                    this.consume(\n                        TokenType.IDENTIFIER,\n                        'Expected parameter name.',\n                    ),\n                );\n            } while (this.match(TokenType.COMMA));\n        }\n\n        this.consume(TokenType.RIGHT_PAREN, 'Expected \")\" after parameters.');\n        this.consume(TokenType.LEFT_BRACE, `Expected \"{\" before ${kind} body.`);\n\n        const body = this.block();\n\n        return new Expr.Function(parameters, body);\n    }\n\n    // classDecl -> IDENTIFIER \"{\" function* \"}\" ;\n    private classDeclaration() {\n        const name = this.consume(\n            TokenType.IDENTIFIER,\n            'Expected a name for the class.',\n        );\n\n        this.consume(TokenType.LEFT_BRACE, 'Expected \"{\" after class name.');\n\n        const methods: Stmt.Function[] = [];\n        const classMethods: Stmt.Function[] = [];\n\n        while (!this.isAtEnd() && !this.check(TokenType.RIGHT_BRACE)) {\n            const isStatic = this.match(TokenType.CLASS);\n            (isStatic ? classMethods : methods).push(this.function('method'));\n        }\n\n        this.consume(TokenType.RIGHT_BRACE, 'Expected \"}\" after class.');\n\n        return new Class(name, methods, classMethods);\n    }\n\n    // varDecl -> IDENTIFIER (\"=\" expression)? \";\" ;\n    private varDeclaration() {\n        const name = this.consume(\n            TokenType.IDENTIFIER,\n            'Expected a variable name',\n        );\n\n        let initializer = this.match(TokenType.EQUAL)\n            ? this.expression()\n            : new Expr.Literal(null);\n\n        this.consume(TokenType.SEMI, 'Expected \";\" after variable declaration');\n        return new Stmt.Var(name, initializer);\n    }\n\n    //statement → exprStmt | printStmt | block | ifStmt | whileStmt  | forStmt | breakStmt | returnStmt ;\n    private statement(): Stmt.Stmt {\n        if (this.match(TokenType.PRINT)) {\n            return this.printStatement();\n        } else if (this.match(TokenType.LEFT_BRACE)) {\n            return new Stmt.Block(this.block());\n        } else if (this.match(TokenType.IF)) {\n            return this.ifStatement();\n        } else if (this.match(TokenType.WHILE)) {\n            return this.whileStatement();\n        } else if (this.match(TokenType.FOR)) {\n            return this.forStatement();\n        } else if (this.match(TokenType.BREAK)) {\n            return this.breakStatement();\n        } else if (this.match(TokenType.RETURN)) {\n            return this.returnStatement();\n        } else {\n            return this.expressionStatement();\n        }\n    }\n\n    // ifStmt → \"if\" \"(\" expression \")\" statement ( \"else\" statement )? ;\n    private ifStatement() {\n        this.consume(TokenType.LEFT_PAREN, 'Expected \"(\" after \"if\".');\n        const condition = this.expression();\n        this.consume(TokenType.RIGHT_PAREN, 'Expected \")\" after if condition.');\n\n        const thenBranch = this.statement();\n        let elseBranch;\n        if (this.match(TokenType.ELSE)) {\n            elseBranch = this.statement();\n        }\n\n        return new Stmt.If(condition, thenBranch, elseBranch);\n    }\n\n    // whileStmt -> \"while\" \"(\" condition \")\" statement ;\n    private whileStatement() {\n        this.consume(TokenType.LEFT_PAREN, 'Expected \"(\" after \"while\".');\n        const condition = this.expression();\n        this.consume(\n            TokenType.RIGHT_PAREN,\n            'Expected \")\" after while condition.',\n        );\n\n        try {\n            this.loopDepth++;\n            const body = this.statement();\n\n            return new Stmt.While(condition, body);\n        } finally {\n            this.loopDepth--;\n        }\n    }\n\n    // forStmt -> \"for\" \"(\" (varDecl | exprStmt | \";\") expr? \";\" expr?) statement ;\n    // For loop is implemented by desugaring it to a while loop\n    private forStatement() {\n        this.consume(TokenType.LEFT_PAREN, 'Expeceted \"(\" after \"for\".');\n\n        // Get initializer\n        let initializer;\n        if (this.match(TokenType.SEMI)) {\n            initializer = undefined;\n        } else if (this.match(TokenType.VAR)) {\n            initializer = this.varDeclaration();\n        } else {\n            initializer = this.expressionStatement();\n        }\n\n        // Get condition\n        let condition;\n        if (!this.check(TokenType.SEMI)) {\n            condition = this.expression();\n        }\n        this.consume(TokenType.SEMI, 'Expected \";\" after for condition.');\n\n        // Get increment\n        let increment;\n        if (!this.check(TokenType.RIGHT_PAREN)) {\n            increment = this.expression();\n        }\n        this.consume(TokenType.RIGHT_PAREN, 'Expected \")\" after for clauses.');\n\n        try {\n            this.loopDepth++;\n\n            // Get body\n            let body = this.statement();\n\n            // If the increment is defined, add it at the end of the body block\n            if (increment) {\n                body = new Stmt.Block([body, new Stmt.Expression(increment)]);\n            }\n\n            // If no condition is defined, then set it to true\n            if (!condition) {\n                condition = new Expr.Literal(true);\n            }\n            body = new Stmt.While(condition, body);\n\n            // If an intializer is defined the add it before the while loop execution\n            if (initializer) {\n                body = new Stmt.Block([initializer, body]);\n            }\n\n            return body;\n        } finally {\n            this.loopDepth--;\n        }\n    }\n\n    // breakStmt -> \"break\" \";\" ;\n    private breakStatement() {\n        if (this.loopDepth <= 0) {\n            this.error(\n                this.previous(),\n                'Must be inside a loop to use \"break\".',\n            );\n        }\n\n        this.consume(TokenType.SEMI, 'Expected \";\" after \"break\".');\n        return new Stmt.Break();\n    }\n\n    private returnStatement() {\n        const keywrod = this.previous();\n\n        let value: Expr.Expr = new Expr.Literal(null);\n        if (!this.check(TokenType.SEMI)) {\n            value = this.expression();\n        }\n\n        this.consume(TokenType.SEMI, 'Expected \";\" after return value.');\n\n        return new Stmt.Return(keywrod, value);\n    }\n\n    // printStmt -> \"print\" expr \";\" ;\n    private printStatement() {\n        const expr = this.expression();\n        this.consume(\n            TokenType.SEMI,\n            'Expected \";\" at the end of the expression.',\n        );\n        return new Stmt.Print(expr);\n    }\n\n    // exprStmt -> expression \";\"\n    private expressionStatement() {\n        const expr = this.expression();\n        this.consume(\n            TokenType.SEMI,\n            'Expected \";\" at the end of the expression.',\n        );\n        return new Stmt.Expression(expr);\n    }\n\n    // block -> (declaration)* \"}\" ;\n    private block(): Stmt.Stmt[] {\n        const statements = [];\n\n        while (!this.check(TokenType.RIGHT_BRACE) && !this.isAtEnd()) {\n            const statement = this.declaration();\n\n            if (statement) {\n                statements.push(statement);\n            }\n        }\n\n        this.consume(TokenType.RIGHT_BRACE, 'Expected \"}\" after block.');\n        return statements;\n    }\n\n    // expression → assignment\n    private expression(): Expr.Expr {\n        return this.assignment();\n    }\n\n    // assignment -> ( call \".\" )? identifier \"=\" assignment | logic_or ;\n    private assignment(): Expr.Expr {\n        const expr = this.or();\n\n        if (this.match(TokenType.EQUAL)) {\n            const equals = this.previous();\n            const value = this.assignment();\n\n            if (expr instanceof Expr.Variable) {\n                return new Expr.Assign(expr.name, value);\n            } else if (expr instanceof Expr.Get) {\n                return new Expr.Set(expr.object, expr.name, value);\n            }\n\n            this.error(equals, 'Invalid assignment target.');\n        }\n\n        return expr;\n    }\n\n    // logic_or -> logic_and ( \"||\" logic_and )*\n    private or() {\n        let expr = this.and();\n\n        while (this.match(TokenType.OR) && !this.isAtEnd()) {\n            const operator = this.previous();\n            const right = this.and();\n            expr = new Expr.Logical(expr, operator, right);\n        }\n\n        return expr;\n    }\n\n    // logic_and -> equality ( \"&&\" equality )*\n    private and() {\n        let expr = this.equality();\n\n        while (this.match(TokenType.AND) && !this.isAtEnd()) {\n            const operator = this.previous();\n            const right = this.and();\n            expr = new Expr.Logical(expr, operator, right);\n        }\n\n        return expr;\n    }\n\n    // coma -> equality ( \",\" equality )* ;\n    private coma(): Expr.Expr {\n        let expr = this.equality();\n\n        while (this.match(TokenType.COMMA)) {\n            const operator = this.previous();\n            const right = this.equality();\n            expr = new Expr.Binary(expr, operator, right);\n        }\n\n        return expr;\n    }\n\n    // equality → comparison ( ( \"!=\" | \"==\" ) comparison )* ;\n    private equality(): Expr.Expr {\n        let expr = this.comparison();\n\n        while (this.match(TokenType.BANG_EQUAL, TokenType.EQUAL_EQUAL)) {\n            const operator = this.previous();\n            const right = this.comparison();\n            expr = new Expr.Binary(expr, operator, right);\n        }\n\n        return expr;\n    }\n\n    // comparison → addition ( ( \">\" | \">=\" | \"<\" | \"<=\" ) addition )* ;\n    private comparison(): Expr.Expr {\n        let expr = this.addition();\n\n        while (\n            this.match(\n                TokenType.GREATER,\n                TokenType.GREATE_EQUAL,\n                TokenType.LESS,\n                TokenType.LESS_EQUAL,\n            )\n        ) {\n            const operator = this.previous();\n            const right = this.addition();\n            expr = new Expr.Binary(expr, operator, right);\n        }\n\n        return expr;\n    }\n\n    // addition → multiplication ( ( \"-\" | \"+\" ) multiplication )* ;\n    private addition(): Expr.Expr {\n        let expr = this.multiplication();\n\n        while (this.match(TokenType.PLUS, TokenType.MINUS)) {\n            const operator = this.previous();\n            const right = this.multiplication();\n            expr = new Expr.Binary(expr, operator, right);\n        }\n\n        return expr;\n    }\n\n    // multiplication → unary ( ( \"/\" | \"*\" ) unary )* ;\n    private multiplication(): Expr.Expr {\n        let expr = this.unary();\n\n        while (this.match(TokenType.SLASH, TokenType.STAR)) {\n            const operator = this.previous();\n            const right = this.multiplication();\n            expr = new Expr.Binary(expr, operator, right);\n        }\n\n        return expr;\n    }\n\n    // unary → ( \"!\" | \"-\" ) unary\n    //         | call ;\n    private unary(): Expr.Expr {\n        if (this.match(TokenType.BANG, TokenType.MINUS)) {\n            const operator = this.previous();\n            const right = this.unary();\n            return new Expr.Unary(operator, right);\n        } else {\n            return this.call();\n        }\n    }\n\n    // call -> primary ( \"(\" arguments? \")\" | \".\" IDENTIFIER )* ;\n    private call(): Expr.Expr {\n        let expr = this.primary();\n\n        while (true) {\n            if (this.match(TokenType.LEFT_PAREN)) {\n                expr = this.finishCall(expr);\n            } else if (this.match(TokenType.DOT)) {\n                const name = this.consume(\n                    TokenType.IDENTIFIER,\n                    'Expected property name after \".\".',\n                );\n                expr = new Expr.Get(expr, name);\n            } else {\n                break;\n            }\n        }\n\n        return expr;\n    }\n\n    // arguments -> expr (\",\" expr)*\n    private finishCall(callee: Expr.Expr): Expr.Expr {\n        const args = [];\n        if (!this.check(TokenType.RIGHT_PAREN)) {\n            do {\n                if (args.length > 8) {\n                    this.error(\n                        this.peek(),\n                        'Cannot have more than 8 arguments.',\n                    );\n                }\n\n                args.push(this.expression());\n            } while (this.match(TokenType.COMMA));\n        }\n\n        const paren = this.consume(\n            TokenType.RIGHT_PAREN,\n            'Expected \")\" after arguments.',\n        );\n\n        return new Expr.Call(callee, paren, args);\n    }\n\n    // primary → NUMBER | STRING | \"false\" | \"true\" | \"nil\" | \"(\" expression \")\" | INDENTIFIER ;\n    private primary(): Expr.Expr {\n        if (this.match(TokenType.FALSE)) {\n            return new Expr.Literal(false);\n        } else if (this.match(TokenType.TRUE)) {\n            return new Expr.Literal(true);\n        } else if (this.match(TokenType.NIL)) {\n            return new Expr.Literal(null);\n        }\n\n        if (this.match(TokenType.NUMBER, TokenType.STRING)) {\n            return new Expr.Literal(this.previous().literal);\n        }\n\n        if (this.match(TokenType.LEFT_PAREN)) {\n            let expr = this.expression();\n\n            this.consume(\n                TokenType.RIGHT_PAREN,\n                `Expected ')' after expression.`,\n            );\n\n            return new Expr.Grouping(expr);\n        }\n\n        if (this.match(TokenType.IDENTIFIER)) {\n            return new Expr.Variable(this.previous());\n        }\n\n        if (this.match(TokenType.FUN)) {\n            return this.functionBody('function');\n        }\n\n        if (this.match(TokenType.THIS)) {\n            return new Expr.This(this.previous());\n        }\n\n        throw this.error(this.peek(), 'Expected expression');\n    }\n\n    private match(...types: TokenType[]) {\n        for (let type of types) {\n            if (this.check(type)) {\n                this.advance();\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private check(type: TokenType) {\n        return this.isAtEnd() ? false : this.peek().type === type;\n    }\n\n    private advance() {\n        if (!this.isAtEnd()) {\n            this.current++;\n        }\n\n        return this.previous();\n    }\n\n    private isAtEnd() {\n        return this.peek().type === TokenType.EOF;\n    }\n\n    private peek() {\n        return this.tokens[this.current];\n    }\n\n    private previous() {\n        return this.tokens[this.current - 1];\n    }\n\n    private consume(type: TokenType, message: string) {\n        if (this.check(type)) {\n            return this.advance();\n        } else {\n            throw this.error(this.peek(), message);\n        }\n    }\n\n    private synchronize() {\n        this.advance();\n\n        while (!this.isAtEnd()) {\n            switch (this.peek().type) {\n                case TokenType.CLASS:\n                case TokenType.FUN:\n                case TokenType.VAR:\n                case TokenType.FOR:\n                case TokenType.IF:\n                case TokenType.WHILE:\n                case TokenType.PRINT:\n                case TokenType.RETURN:\n                    return;\n            }\n\n            this.advance();\n        }\n    }\n\n    private error(token: Token, message: string) {\n        this.config.error(token, message);\n        return new ParserError();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/parser.ts","import Token from './token';\nimport { RuntimeException } from './interpreter';\n\nexport default class Environment {\n    enclosing?: Environment;\n    values = new Map<string, any>();\n\n    constructor(enclosing?: Environment) {\n        this.enclosing = enclosing;\n    }\n\n    define(name: string, value: any) {\n        this.values.set(name, value);\n    }\n\n    assign(name: Token, value: any) {\n        if (this.values.has(name.lexeme)) {\n            this.values.set(name.lexeme, value);\n        } else if (this.enclosing) {\n            this.enclosing.assign(name, value);\n        } else {\n            throw new RuntimeException(\n                name,\n                `Undefined variable for \"${name.lexeme}\".`,\n            );\n        }\n    }\n\n    assignAt(distance: number, name: Token, value: any) {\n        return this.ancestor(distance).values.set(name.lexeme, value);\n    }\n\n    get(name: Token): any {\n        if (this.values.has(name.lexeme)) {\n            return this.values.get(name.lexeme);\n        } else if (this.enclosing) {\n            return this.enclosing.get(name);\n        }\n\n        throw new RuntimeException(\n            name,\n            `Undefined variable for \"${name.lexeme}\".`,\n        );\n    }\n\n    getAt(distance: number, name: string) {\n        return this.ancestor(distance).values.get(name);\n    }\n\n    ancestor(distance: number): Environment {\n        return distance === 0 ? this : this.enclosing!.ancestor(distance - 1);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/environment.ts","import { saveGist, loadGist } from './gist';\nimport { examples } from './examples';\nimport * as loxLanguage from './lox-language/main';\n\nimport Runner from '../core/runner';\n\ndeclare global {\n    interface Window { \n        require: any;\n        monaco: any;\n    }\n}\n\ninterface StateConfig {\n    onchange(src: string): void;\n}\n\nclass PlaygroundState {\n    config: StateConfig;\n\n    constructor(config: StateConfig) {\n        window.addEventListener('popstate', async (evt: PopStateEvent) => {\n            const src = await this.load();\n            config.onchange(src || '');\n        });\n    }\n\n    async load(): Promise<string | undefined> {\n        const url = new URL(window.location.href);\n        const params = new URLSearchParams(url.search);\n\n        if (params.has('id')) {\n            return loadGist(params.get('id')!);\n        }\n    }\n\n    async save(src: string): Promise<string> {\n        const id = await saveGist(src);\n        \n        history.pushState(\n            {},\n            document.title,\n            `?id=${id}`,\n        );\n\n        return id;\n    }\n}\n\nfunction loadMonaco(): Promise<any> {\n    return new Promise((resolve, reject) => {\n        window.require.config({ paths: { 'vs': 'monaco-editor' }});\n        window.require(['vs/editor/editor.main'], () => {\n            resolve(window.monaco);\n        });\n    })\n}\n\nconst presetSelect = document.querySelector('#preset-select') as HTMLSelectElement;\nconst saveButton = document.querySelector('#save-button')!; \nconst runButton = document.querySelector('#run-button')!;\nconst editorContainer = document.querySelector('#left-container')!;\nconst logContainer = document.querySelector('#right-container')!;\n\nfor (let { name, content } of examples) {\n    const option = document.createElement('option');\n    \n    option.text = name;\n    option.value = content;\n\n    presetSelect.appendChild(option);\n}\n\nlet editor: any;\nlet log: any;\n\nconst state = new PlaygroundState({\n    onchange(value) {\n        editor.setValue(value);\n    }\n});\n\nPromise.all([\n    loadMonaco(),\n    state.load(),\n]).then(([monaco, value]) => {\n    loxLanguage.registerLanguage(monaco);\n    \n    editor = monaco.editor.create(editorContainer, {\n        value: value || presetSelect.value,\n        language: loxLanguage.id,\n    });\n\n    loxLanguage.registerEditor(monaco, editor);\n\n    log = monaco.editor.create(logContainer, {\n        value: '',\n\n        lineNumbers: false,\n        scrollBeyondLastLine: false,\n        \n        readOnly: true,\n        contextmenu: false,\n        hideCursorInOverviewRuler: true,\n\n        minimap: {\n            enabled: false\n        },\n\n        theme: 'vs-dark',\n    });\n\n    window.addEventListener('resize', () => {\n        editor.layout();\n        log.layout();\n    });\n    \n    presetSelect.addEventListener('change', () => {\n        editor.setValue(presetSelect.value);\n    });\n\n    saveButton.addEventListener('click', () => {\n        state.save(\n            editor.getValue()\n        );\n    });\n\n    runButton.addEventListener('click', () => {\n        const value = editor.getValue();\n\n        const logLines: string[] = [];\n        const addLogLine = function(msg: string) {\n            logLines.push(msg);\n            log.setValue(logLines.join('\\n'));\n        }\n\n        const runner = new Runner({\n            debug(msg: string) { \n                console.debug(msg)\n                addLogLine(`🔎 ${msg}`);\n            },\n            log(msg: string) {\n                console.log(msg)\n                addLogLine(`  ${msg}`);\n            },\n            warning(msg: string) {\n                console.warn(msg)\n                addLogLine(`⚠️ ${msg}`);\n            },\n            error(msg: string) {\n                console.error(msg);\n                addLogLine(`️❌ ${msg}`);\n            },\n        });\n\n        runner.run(value);\n    });\n\n    document.body.classList.add('ready');\n});\n\n\n// WEBPACK FOOTER //\n// ./src/playground/index.ts","const GITHUB_API = 'https://api.github.com';\n\nconst MAIN_FILE_NAME = 'main.lox';\nconst DEFAULT_DESCRIPTION = `Created by https://pmdartus.github.io/tlox/`;\n\nexport async function saveGist(src: string) {\n    const payload = {\n        description: DEFAULT_DESCRIPTION,\n        public: true,\n        files: {\n            [MAIN_FILE_NAME]: {\n                content: src,\n            },\n        },\n    };\n\n    const response = await fetch(`${GITHUB_API}/gists`, {\n        method: 'POST',\n        body: JSON.stringify(payload),\n    });\n\n    const res = await response.json();\n\n    if (!response.ok) {\n        throw new Error(res.message);\n    }\n\n    return res.id;\n}\n\nexport async function loadGist(id: string) {\n    const response = await fetch(`${GITHUB_API}/gists/${id}`);\n    const res = await response.json();\n\n    if (!response.ok) {\n        throw new Error(res.message);\n    }\n\n    return res.files[MAIN_FILE_NAME].content;\n}\n\n\n// WEBPACK FOOTER //\n// ./src/playground/gist.ts","export const examples: {\n    name: string,\n    content: string, \n}[] = [\n    {\n        name: 'Hello world!',\n        content: [\n            '// Print with the \"print\" keyword',\n            'print \"Hello World!\";',\n        ].join('\\n'),\n    },\n    {\n        name: 'Expressions',\n        content: [\n            '// Some basic arithmetic works as you\\'d expect.',\n            'print 1 + 1; // = 2',\n            'print 0.1 + 0.2; // = 0.3',\n            'print 8 - 1; // = 7',\n            'print 10 * 2; // = 20',\n            'print 35 / 5; // = 7',\n            '',\n            '// Negation uses the ! symbol',\n            'print !true; // = false',\n            'print !false; // = true',\n            '',\n            '// Equality is ===',\n            'print 1 == 1; // = true',\n            'print 2 == 1; // = false',\n            '',\n            '// Inequality is !==',\n            'print 1 != 1; // = false',\n            'print 2 != 1; // = true',\n            '',\n            '// More comparisons',\n            'print 1 < 10; // = true',\n            'print 1 > 10; // = false',\n            'print 2 <= 2; // = true',\n            'print 2 >= 2; // = true',\n                '',\n            '// Strings are concatenated with +',\n            'print \"Hello \" + \"world!\"; // = \"Hello world!\"',\n            'print \"1, 2, \" + 3; // = \"1, 2, 3\"',\n        ].join('\\n'),\n    },\n    {\n        name: 'Flow Control',\n        content: [\n            '// The `if` structure works as you\\'d expect',\n            'var condition = true;',\n            'if (condition) {',\n            '    print \"yes\";',\n            '} else {',\n            '    print \"no\";',\n            '}',\n            '',\n            '// As does `while`',\n            'var a = 1;',\n            'while (a < 10) {',\n            '    print \"While \" + a;',\n            '    a = a + 1;',\n            '}',\n            '',\n            '// The `for` loop is the same as C and Java:',\n            '// initialization; continue condition; iteration.',\n            'for (var a = 1; a < 10; a = a + 1) {',\n            '    print \"For \" + a;',\n            '}',\n        ].join('\\n'),\n    },\n    {\n        name: 'Function',\n        content: [\n            '// Functions are defined with the \"fun\" keyword',\n            'fun fibonacci(n) {',\n            '    if (n <= 1) return n;',\n            '    return fibonacci(n - 2) + fibonacci(n - 1);',\n            '}',\n            '',\n            'for (var i = 0; i < 10; i = i + 1) {',\n            '    print \"Fibonacci \" + fibonacci(i);',\n            '}',\n            '',\n            'fun makeClosure() {',\n            '    var i = 0;',\n            '    ',\n            '    // You can define a closure into another function',\n            '    fun count() {',\n            '        i = i + 1;',\n            '        return i;',\n            '    }',\n            '',\n            '   return count;',\n            '}',\n            '',\n            'var counter = makeClosure();',\n            'for (var i = 0; i < 10; i = i + 1) {',\n            '    print \"Closure \" + counter();',\n            '}',\n        ].join('\\n'),\n    },\n    {\n        name: 'Classes',\n        content: [\n            '// Class definition',\n            'class Rectangle {',\n            '    // Contructor',\n            '    init(height, width) {',\n            '        this.height = height;',\n            '        this.width = width;',\n            '    }',\n            '',\n            '    // Method',\n            '    calcArea() {',\n            '        return this.height * this.width;',\n            '    }',\n            '',\n            '    // Static methods',\n            '    class equals(a, b) {',\n            '        return a.height == b.height and a.width == b.width;',\n            '    }',\n            '}',\n            '',\n            'var square = Rectangle(10, 10);',\n            'print \"Area: \" + square.calcArea();',\n            '',\n            'var anotherSquare = Rectangle(10, 10);',\n            'print \"Equals? \" + Rectangle.equals(square, anotherSquare);',\n        ].join('\\n'),\n    }\n]\n\n\n// WEBPACK FOOTER //\n// ./src/playground/examples.ts","import { LANGUAGE_ID, LANGUAGE_CONFIG } from './config';\nimport { MONARCH_TOKEN_PROVIDER } from './syntax';\nimport { completionItemProvider } from './autocomplete';\nimport { parse } from './parser';\n\n/**\n * Lox language identifier\n */\nexport const id = LANGUAGE_ID;\n\n/**\n * Register lox language to monaco editor\n */\nexport function registerLanguage(monaco: any) {\n    const { languages } = monaco;\n\n    languages.register({ id });\n    languages.setLanguageConfiguration(id, LANGUAGE_CONFIG);\n    languages.setMonarchTokensProvider(id, MONARCH_TOKEN_PROVIDER);\n    languages.registerCompletionItemProvider(\n        id,\n        completionItemProvider(monaco),\n    );\n}\n\n/**\n * Register a lox language server like to an editor instance.\n */\nexport function registerEditor(monaco: any, instance: any) {\n    const model = instance.getModel();\n\n    const validateContent = () => {\n        const src: string = model.getValue();\n        const { errors } = parse(src);\n\n        monaco.editor.setModelMarkers(\n            model,\n            'lox',\n            errors,\n        )\n    };\n\n    validateContent();\n\n    instance.onDidChangeModelContent(validateContent);\n}\n\n\n// WEBPACK FOOTER //\n// ./src/playground/lox-language/main.ts","export const LANGUAGE_ID = 'lox';\n\nexport const LANGUAGE_CONFIG = {\n    comments: {\n        lineComment: '//',\n        blockComment: ['/*', '*/'],\n    },\n    brackets: [['{', '}'], ['(', ')']],\n    autoClosingPairs: [\n        { open: '{', close: '}' },\n        { open: '(', close: ')' },\n        { open: '\"', close: '\"', notIn: ['string'] },\n        { open: '/*', close: ' */', notIn: ['string'] },\n    ],\n    surroundingPairs: [\n        ['{', '}'],\n        ['(', ')'],\n        ['\"', '\"'],\n    ],\n};\n\n\n// WEBPACK FOOTER //\n// ./src/playground/lox-language/config.ts","import { KEYWORDS } from './syntax';\n\nexport function completionItemProvider(monaco: any) {\n    const { CompletionItemKind } = monaco.languages;\n\n    const keywordItems = KEYWORDS.map(keyword => ({\n        label: keyword,\n        kind: CompletionItemKind.Text,\n    }));\n\n    const snippetsItems = [\n        {\n            label: 'print',\n            documentation: 'Print statement',\n            kind: CompletionItemKind.Snippet,\n            insertText: {\n                value: 'print $1;',\n            },\n        },\n        {\n            label: 'fun',\n            documentation: 'Function Statement',\n            kind: CompletionItemKind.Snippet,\n            insertText: {\n                value: ['fun ${1:name} (${2:params}) {', '\\t$3', '}'].join(\n                    '\\n',\n                ),\n            },\n        },\n        {\n            label: 'class',\n            documentation: 'Class Statement',\n            kind: CompletionItemKind.Snippet,\n            insertText: {\n                value: [\n                    'class ${1:Name} {',\n                    '\\tinit(${2:params}) {',\n                    '\\t\\t$3',\n                    '\\t}',\n                    '}',\n                ].join('\\n'),\n            },\n        },\n        {\n            label: 'if',\n            documentation: 'If Statement',\n            kind: CompletionItemKind.Snippet,\n            insertText: {\n                value: ['if (${1:cond}) {', '\\t$2', '}'].join('\\n'),\n            },\n        },\n        {\n            label: 'ifelse',\n            documentation: 'If/Else Statement',\n            kind: CompletionItemKind.Snippet,\n            insertText: {\n                value: [\n                    'if (${1:cond}) {',\n                    '\\t$2',\n                    '} else {',\n                    '\\t$3',\n                    '}',\n                ].join('\\n'),\n            },\n        },\n        {\n            label: 'for',\n            documentation: 'For Loop',\n            kind: CompletionItemKind.Snippet,\n            insertText: {\n                value: [\n                    'for (var ${1:i} = 0; $1 < ${2:10}; $1 = $1 + 1) {',\n                    '\\t$0',\n                    '}',\n                ].join('\\n'),\n            },\n        },\n        {\n            label: 'while',\n            documentation: 'While Loop',\n            kind: CompletionItemKind.Snippet,\n            insertText: {\n                value: ['while (${1:true}) {', '\\t$2', '}'].join('\\n'),\n            },\n        },\n    ];\n\n    return {\n        provideCompletionItems() {\n            return [...keywordItems, ...snippetsItems];\n        },\n    };\n}\n\n\n// WEBPACK FOOTER //\n// ./src/playground/lox-language/autocomplete.ts","import { getLocator } from 'locate-character';\n\nimport Scanner from '../../core/scanner';\nimport Parser from '../../core/parser';\n\n/**\n * Marker type definition for monaco editor.\n * Extracted from: monaco-editor/monaco.d.ts\n */\nenum Severity {\n    Ignore = 0,\n    Info = 1,\n    Warning = 2,\n    Error = 3,\n}\n\ninterface EditorMaker {\n    code?: string;\n    severity: Severity;\n    message: string;\n    source?: string;\n    startLineNumber: number;\n    startColumn: number;\n    endLineNumber: number;\n    endColumn: number;\n}\n\nconst LOCATION_CONFIG = {\n    offsetLine: 1,\n    offsetColumn: 1\n};\n\nexport function parse(src: string) {\n    const locate = getLocator(src, LOCATION_CONFIG);\n    const errors: EditorMaker[] = [];\n    \n    const scanner = new Scanner(src, {\n        error(location, message) {\n            const { line, column } = locate(location as any);\n            errors.push({\n                message,\n                startLineNumber: line,\n                endLineNumber: line,\n                startColumn: column,\n                endColumn: column,\n                severity: Severity.Error,\n            })\n        }\n    });\n    const tokens = scanner.scanTokens();\n\n    if (errors.length) {\n        return { errors };\n    }\n\n    const parser = new Parser(tokens, {\n        error(token, message) {\n            const start = locate(token.start as any);\n            const end = locate(token.end as any);\n\n            errors.push({\n                message,\n                startLineNumber: start.line,\n                endLineNumber: end.line,\n                startColumn: start.column,\n                endColumn: end.column,\n                severity: Severity.Error,\n            })\n        }\n    });\n    const statements = parser.parse();\n\n    return { errors, statements };\n}\n\n\n// WEBPACK FOOTER //\n// ./src/playground/lox-language/parser.ts","/* /!\\ Genreated via \"npm run genreate-ast\" /!\\ */\n\nimport Token from '../token';\nimport { Stmt } from './stmt';\n\nexport interface ExprVisitor<V> {\n    visitAssignExpr(expr: Assign): V;\n    visitBinaryExpr(expr: Binary): V;\n    visitGroupingExpr(expr: Grouping): V;\n    visitLiteralExpr(expr: Literal): V;\n    visitUnaryExpr(expr: Unary): V;\n    visitCallExpr(expr: Call): V;\n    visitGetExpr(expr: Get): V;\n    visitSetExpr(expr: Set): V;\n    visitThisExpr(expr: This): V;\n    visitLogicalExpr(expr: Logical): V;\n    visitVariableExpr(expr: Variable): V;\n    visitFunctionExpr(expr: Function): V;\n}\n\nexport abstract class Expr {\n    abstract accept<V>(visitior: ExprVisitor<V>): V;\n}\n\nexport class Assign extends Expr {\n    name: Token;\n    value: Expr;\n    constructor(name: Token, value: Expr) {\n        super();\n        this.name = name;\n        this.value = value;\n    }\n    accept<V>(visitor: ExprVisitor<V>): V {\n        return visitor.visitAssignExpr(this);\n    }\n}\n\nexport class Binary extends Expr {\n    left: Expr;\n    operator: Token;\n    right: Expr;\n    constructor(left: Expr, operator: Token, right: Expr) {\n        super();\n        this.left = left;\n        this.operator = operator;\n        this.right = right;\n    }\n    accept<V>(visitor: ExprVisitor<V>): V {\n        return visitor.visitBinaryExpr(this);\n    }\n}\n\nexport class Grouping extends Expr {\n    expr: Expr;\n    constructor(expr: Expr) {\n        super();\n        this.expr = expr;\n    }\n    accept<V>(visitor: ExprVisitor<V>): V {\n        return visitor.visitGroupingExpr(this);\n    }\n}\n\nexport class Literal extends Expr {\n    value: any;\n    constructor(value: any) {\n        super();\n        this.value = value;\n    }\n    accept<V>(visitor: ExprVisitor<V>): V {\n        return visitor.visitLiteralExpr(this);\n    }\n}\n\nexport class Unary extends Expr {\n    operation: Token;\n    right: Expr;\n    constructor(operation: Token, right: Expr) {\n        super();\n        this.operation = operation;\n        this.right = right;\n    }\n    accept<V>(visitor: ExprVisitor<V>): V {\n        return visitor.visitUnaryExpr(this);\n    }\n}\n\nexport class Call extends Expr {\n    callee: Expr;\n    paren: Token;\n    args: Expr[];\n    constructor(callee: Expr, paren: Token, args: Expr[]) {\n        super();\n        this.callee = callee;\n        this.paren = paren;\n        this.args = args;\n    }\n    accept<V>(visitor: ExprVisitor<V>): V {\n        return visitor.visitCallExpr(this);\n    }\n}\n\nexport class Get extends Expr {\n    object: Expr;\n    name: Token;\n    constructor(object: Expr, name: Token) {\n        super();\n        this.object = object;\n        this.name = name;\n    }\n    accept<V>(visitor: ExprVisitor<V>): V {\n        return visitor.visitGetExpr(this);\n    }\n}\n\nexport class Set extends Expr {\n    object: Expr;\n    name: Token;\n    value: Expr;\n    constructor(object: Expr, name: Token, value: Expr) {\n        super();\n        this.object = object;\n        this.name = name;\n        this.value = value;\n    }\n    accept<V>(visitor: ExprVisitor<V>): V {\n        return visitor.visitSetExpr(this);\n    }\n}\n\nexport class This extends Expr {\n    keyword: Token;\n    constructor(keyword: Token) {\n        super();\n        this.keyword = keyword;\n    }\n    accept<V>(visitor: ExprVisitor<V>): V {\n        return visitor.visitThisExpr(this);\n    }\n}\n\nexport class Logical extends Expr {\n    left: Expr;\n    operator: Token;\n    right: Expr;\n    constructor(left: Expr, operator: Token, right: Expr) {\n        super();\n        this.left = left;\n        this.operator = operator;\n        this.right = right;\n    }\n    accept<V>(visitor: ExprVisitor<V>): V {\n        return visitor.visitLogicalExpr(this);\n    }\n}\n\nexport class Variable extends Expr {\n    name: Token;\n    constructor(name: Token) {\n        super();\n        this.name = name;\n    }\n    accept<V>(visitor: ExprVisitor<V>): V {\n        return visitor.visitVariableExpr(this);\n    }\n}\n\nexport class Function extends Expr {\n    parameter: Token[];\n    body: Stmt[];\n    constructor(parameter: Token[], body: Stmt[]) {\n        super();\n        this.parameter = parameter;\n        this.body = body;\n    }\n    accept<V>(visitor: ExprVisitor<V>): V {\n        return visitor.visitFunctionExpr(this);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/ast/expr.ts","import { locate } from 'locate-character';\n\nimport Parser from './parser';\nimport Scanner from './scanner';\nimport Token, { TokenType } from './token';\nimport Interpreter, { RuntimeException } from './interpreter';\nimport Resolver from './resolver';\nimport { Logger } from './logger';\n\nconst LOCATION_CONFIG = {\n    offsetLine: 1\n};\n\nexport default class Runner {\n    source: string;\n\n    hadError = false;\n    hadRuntimeError = false;\n    interpreter = new Interpreter(this);\n\n    logger: Logger;\n\n    constructor(logger: Logger) {\n        this.logger = logger;\n    }\n\n    run(source: string) {\n        this.source = source;\n\n        const scanner = new Scanner(source, {\n            error: (line, msg) => this.error(line, msg)\n        });\n        const tokens = scanner.scanTokens();\n\n        const parser = new Parser(tokens, {\n            error: (token, msg) => this.errorToken(token, msg)\n        });\n        const statements = parser.parse();\n\n        if (this.hadError) {\n            return;\n        }\n\n        const resolver = new Resolver(this.interpreter, this);\n        resolver.resolve(statements);\n\n        if (this.hadError) {\n            return;\n        }\n\n        this.interpreter.interpret(statements);\n    }\n\n    error(location: number, message: string) {\n        const { line, column } = locate(this.source, location, LOCATION_CONFIG);\n        this.reportError(line, column, '', message);\n    }\n\n    errorToken(token: Token, message: string) {\n        const { line, column } = locate(this.source, token.start, LOCATION_CONFIG);\n        if (token.type === TokenType.EOF) {\n            this.reportError(line, column, 'at end', message);\n        } else {\n            this.reportError(line, column, `at \"${token.lexeme}\"`, message);\n        }\n    }\n\n    runtimeError(error: RuntimeException) {\n        const { line, column } = locate(this.source, error.token.start, LOCATION_CONFIG);\n        this.logger.error(`[${line}:${column}] ${error.message}`);\n        this.hadRuntimeError = true;\n    }\n\n    reportError(line: number, column: number, where: string, message: string) {\n        this.logger.error(`[${line}:${column}] Error ${where}: ${message}`);\n        this.hadError = true;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/runner.ts","import { LoxInstance } from './class';\nimport Environment from './environment';\nimport Interpreter, { ReturnException } from './interpreter';\n\nimport * as Stmt from './ast/stmt';\nimport * as Expr from './ast/expr';\n\nexport abstract class LoxCallable {\n    abstract arity: number;\n    abstract call(interpreter: Interpreter, args: any[]): any;\n}\n\nexport class LoxFunction extends LoxCallable {\n    closure: Environment;\n    name: string | undefined;\n    declaration: Expr.Function;\n    isInitilizer: boolean;\n\n    constructor(\n        name: string | undefined,\n        declaration: Expr.Function,\n        closure: Environment,\n        isInitilizer: boolean,\n    ) {\n        super();\n        this.name = name;\n        this.declaration = declaration;\n        this.closure = closure;\n        this.isInitilizer = isInitilizer;\n    }\n\n    get arity() {\n        return this.declaration.parameter.length;\n    }\n\n    call(interpreter: Interpreter, args: any[]) {\n        const environment = new Environment(this.closure);\n\n        for (let i = 0; i < this.arity; i++) {\n            environment.define(this.declaration.parameter[i].lexeme, args[i]);\n        }\n\n        const body = new Stmt.Block(this.declaration.body);\n\n        try {\n            interpreter.executeBlock(body, environment);\n        } catch (error) {\n            if (error instanceof ReturnException) {\n                return error.value;\n            }\n\n            throw error;\n        }\n\n        if (this.isInitilizer) {\n            return environment.getAt(0, 'this');\n        }\n    }\n\n    bind(instance: LoxInstance) {\n        const environment = new Environment(this.closure);\n        environment.define('this', instance);\n        return new LoxFunction(\n            this.name,\n            this.declaration,\n            environment,\n            this.isInitilizer,\n        );\n    }\n\n    toString() {\n        return `<fn ${this.name || 'anonymous'}>`;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/callable.ts","import Token from './token';\nimport { LoxCallable, LoxFunction } from './callable';\nimport Interpreter, { RuntimeException } from './interpreter';\n\nexport class LoxInstance {\n    klass: LoxClass | null;\n    fields: Map<string, any> = new Map();\n\n    constructor(klass: LoxClass | null) {\n        this.klass = klass;\n    }\n\n    get(name: Token) {\n        if (!this.klass) {\n            return;\n        }\n\n        if (this.fields.has(name.lexeme)) {\n            return this.fields.get(name.lexeme);\n        }\n\n        const method = this.klass.findMethod(this, name);\n        if (method) {\n            return method;\n        }\n\n        throw new RuntimeException(name, `Undefined property ${name.lexeme}.`);\n    }\n\n    set(name: Token, value: any) {\n        this.fields.set(name.lexeme, value);\n    }\n\n    toString() {\n        if (!this.klass) {\n            return;\n        }\n        \n        return `<Instance ${this.klass.name}>`;\n    }\n}\n\nexport class LoxClass extends LoxInstance implements LoxCallable {\n    name: string;\n    methods: { [name: string]: LoxFunction };\n\n    constructor(metaclass: LoxClass | null, name: string, methods: { [name: string]: LoxFunction }) {\n        super(metaclass);\n        this.name = name;\n        this.methods = methods;\n    }\n\n    call(interpreter: Interpreter, args: any[]) {\n        const instance = new LoxInstance(this);\n\n        const init = this.methods['init'];\n        if (init) {\n            init.bind(instance).call(interpreter, args);\n        }\n\n        return instance;\n    }\n\n    findMethod(instance: LoxInstance, name: Token) {\n        if (name.lexeme in this.methods) {\n            return this.methods[name.lexeme].bind(instance);\n        }\n    }\n\n    get arity() {\n        const init = this.methods['init'];\n        return init ? init.arity : 0;\n    }\n\n    toString() {\n        return `<Class ${this.name}>`;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/class.ts","import * as Expr from './ast/expr';\nimport * as Stmt from './ast/stmt';\nimport Interpreter from './interpreter';\nimport Token, { TokenType } from './token';\nimport Runner from './runner';\n\nenum VariableState {\n    DECLARED,\n    DEFINED,\n    READ,\n}\n\ninterface ScopeVariable {\n    name: Token;\n    state: VariableState;\n}\n\ntype Scope = Map<string, ScopeVariable>;\n\nenum FunctionType {\n    NONE,\n    FUNCTION,\n    METHOD,\n    INITIALIZER,\n}\n\nenum ClassType {\n    NONE,\n    CLASS,\n}\n\nexport default class Resolver\n    implements Expr.ExprVisitor<void>, Stmt.StmtVisitor<void> {\n    runner: Runner;\n    interpreter: Interpreter;\n    scopes: Scope[] = [];\n\n    functionType = FunctionType.NONE;\n    classType = ClassType.NONE;\n\n    constructor(interpreter: Interpreter, runner: Runner) {\n        this.runner = runner;\n        this.interpreter = interpreter;\n    }\n\n    visitBlockStmt(stmt: Stmt.Block) {\n        this.beginScope();\n        this.resolve(stmt.statements);\n        const scope = this.endScope();\n\n        for (let variable of scope!.values()) {\n            if (\n                variable.state < VariableState.READ &&\n                variable.name.type !== TokenType.THIS\n            ) {\n                this.runner.errorToken(variable.name, 'Unused variable.');\n            }\n        }\n    }\n\n    visitFunctionStmt(stmt: Stmt.Function) {\n        this.declare(stmt.name);\n        this.define(stmt.name);\n\n        this.resolveFunction(stmt.fn, FunctionType.FUNCTION);\n    }\n\n    visitFunctionExpr(expr: Expr.Function) {\n        this.resolveFunction(expr, FunctionType.FUNCTION);\n    }\n\n    visitVarStmt(stmt: Stmt.Var) {\n        this.declare(stmt.name);\n\n        if (stmt.initializer) {\n            this.resolveExpr(stmt.initializer);\n        }\n\n        this.define(stmt.name);\n    }\n\n    visitVariableExpr(expr: Expr.Variable) {\n        if (this.scopes.length) {\n            const variable = this.currentScope().get(expr.name.lexeme);\n\n            if (variable && variable.state === VariableState.DECLARED) {\n                this.runner.errorToken(\n                    expr.name,\n                    'Cannot read variable before own init.',\n                );\n            }\n        }\n\n        this.resolveLocal(expr, expr.name, true);\n    }\n\n    visitAssignExpr(expr: Expr.Assign) {\n        this.resolveExpr(expr.value);\n        this.resolveLocal(expr, expr.name, false);\n    }\n\n    visitGetExpr(expr: Expr.Get) {\n        this.resolveExpr(expr.object);\n    }\n\n    visitSetExpr(expr: Expr.Set) {\n        this.resolveExpr(expr.value);\n        this.resolveExpr(expr.object);\n    }\n\n    visitClassStmt(stmt: Stmt.Class) {\n        const currentClassType = this.classType;\n        this.classType = ClassType.CLASS;\n\n        this.declare(stmt.name);\n\n        for (let method of stmt.methods) {\n            this.beginScope();\n            this.currentScope().set('this', {\n                name: new Token(TokenType.THIS, 'this', undefined, stmt.name.start),\n                state: VariableState.DEFINED,\n            });\n\n            let type = FunctionType.METHOD;\n            if (method.name.lexeme === 'init') {\n                type = FunctionType.INITIALIZER;\n            }\n\n            this.resolveFunction(method.fn, type);\n\n            this.endScope();\n        }\n\n        for (let method of stmt.classMethods) {\n            this.beginScope();\n            this.currentScope().set('this', {\n                name: new Token(TokenType.THIS, 'this', undefined, stmt.name.start),\n                state: VariableState.DEFINED,\n            });\n\n            this.resolveFunction(method.fn, FunctionType.METHOD);\n\n            this.endScope();\n        }\n\n        this.define(stmt.name);\n\n        this.classType = currentClassType;\n    }\n\n    visitThisExpr(expr: Expr.This) {\n        if (this.classType !== ClassType.CLASS) {\n            this.runner.errorToken(\n                expr.keyword,\n                'Can only be used in class methods.',\n            );\n        }\n\n        this.resolveLocal(expr, expr.keyword, true);\n    }\n\n    visitExpressionStmt(stmt: Stmt.Expression) {\n        this.resolveExpr(stmt.expr);\n    }\n\n    visitIfStmt(stmt: Stmt.If) {\n        this.resolveExpr(stmt.condition);\n        this.resolveStmt(stmt.thenBranch);\n\n        if (stmt.elseBranch) {\n            this.resolveStmt(stmt.elseBranch);\n        }\n    }\n\n    visitPrintStmt(stmt: Stmt.Print) {\n        this.resolveExpr(stmt.expr);\n    }\n\n    visitReturnStmt(stmt: Stmt.Return) {\n        if (this.functionType === FunctionType.NONE) {\n            this.runner.errorToken(\n                stmt.keyword,\n                'Cannot return from top level.',\n            );\n        } else if (this.functionType === FunctionType.INITIALIZER) {\n            this.runner.errorToken(\n                stmt.keyword,\n                'Cannot return a value from the intializer.',\n            );\n        }\n\n        this.resolveExpr(stmt.value);\n    }\n\n    visitWhileStmt(stmt: Stmt.While) {\n        this.resolveExpr(stmt.condition);\n        this.resolveStmt(stmt.body);\n    }\n\n    visitBinaryExpr(expr: Expr.Binary) {\n        this.resolveExpr(expr.left);\n        this.resolveExpr(expr.right);\n    }\n\n    visitCallExpr(expr: Expr.Call) {\n        this.resolveExpr(expr.callee);\n\n        for (let arg of expr.args) {\n            this.resolveExpr(arg);\n        }\n    }\n\n    visitGroupingExpr(expr: Expr.Grouping) {\n        this.resolveExpr(expr.expr);\n    }\n\n    visitLiteralExpr(expr: Expr.Literal) {}\n\n    visitLogicalExpr(expr: Expr.Logical) {\n        this.resolveExpr(expr.left);\n        this.resolveExpr(expr.right);\n    }\n\n    visitUnaryExpr(expr: Expr.Unary) {\n        this.resolveExpr(expr.right);\n    }\n\n    visitBreakStmt() {}\n\n    private beginScope() {\n        this.scopes.push(new Map());\n    }\n\n    private endScope() {\n        return this.scopes.pop();\n    }\n\n    private declare(name: Token) {\n        if (!this.scopes.length) {\n            return;\n        }\n\n        const current = this.currentScope();\n\n        if (current.has(name.lexeme)) {\n            this.runner.errorToken(\n                name,\n                'Duplicate variable declaration in the scope.',\n            );\n        }\n\n        current.set(name.lexeme, {\n            name,\n            state: VariableState.DECLARED,\n        });\n    }\n\n    private define(name: Token) {\n        if (!this.scopes.length) {\n            return;\n        }\n\n        this.currentScope().set(name.lexeme, {\n            name,\n            state: VariableState.DEFINED,\n        });\n    }\n\n    private currentScope() {\n        return this.scopes[this.scopes.length - 1];\n    }\n\n    private resolveFunction(fn: Expr.Function, type: FunctionType) {\n        const enclosingType = this.functionType;\n        this.functionType = type;\n\n        this.beginScope();\n\n        for (let param of fn.parameter) {\n            this.declare(param);\n            this.define(param);\n        }\n        this.resolve(fn.body);\n\n        this.endScope();\n\n        this.functionType = enclosingType;\n    }\n\n    private resolveLocal(expr: Expr.Expr, name: Token, isRead: boolean) {\n        for (let i = this.scopes.length - 1; i >= 0; i--) {\n            if (this.scopes[i].has(name.lexeme)) {\n                this.interpreter.resolve(expr, this.scopes.length - 1 - i);\n\n                this.scopes[i].get(name.lexeme)!.state = VariableState.READ;\n            }\n        }\n    }\n\n    // Dirty code after need to be refactored\n\n    resolve(statements: Stmt.Stmt[]) {\n        for (let statement of statements) {\n            this.resolveStmt(statement);\n        }\n    }\n\n    private resolveStmt(statement: Stmt.Stmt) {\n        statement.accept(this);\n    }\n\n    private resolveExpr(expr: Expr.Expr) {\n        expr.accept(this);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/resolver.ts"],"sourceRoot":""}